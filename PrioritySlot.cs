using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Priority slot", "moochannel", "0.0.1")]
    [Description("Reserved connection slots, added using slot flexibly and auto-kick feature.")]

    class PrioritySlot : CovalencePlugin
    {
        // Do NOT edit this file, instead edit PriortySlot.json in oxide/config and PrioritySlot.en.json in oxide/lang,
        // or create a language file for another language using the 'en' file as a default.

        #region Permissions
        const string permissionPrior = "priorityslot.prior";
        #endregion
        
        #region Configuration

        bool PriorCanConsumeStandard => GetConfig("PriorCanConsumeStandard", true);
        bool StandardCanConsumePrior => GetConfig("StandardCanConsumePrior", false);
        bool KickForReserved => GetConfig("KickForReserved", false);
        bool TeleportBeforeKick => GetConfig("TeleportBeforeKick", true);
        int KickWaitSeconds => GetConfig("KickWaitSeconds", 60);
        int ReservedSlots => GetConfig("ReservedSlots", 5);

        protected override void LoadDefaultConfig()
        {
            Config["PriorCanConsumeStandard"] = PriorCanConsumeStandard;
            Config["StandardCanConsumePrior"] = StandardCanConsumePrior;
            Config["KickForReserved"] = KickForReserved;
            Config["TeleportBeforeKick"] = TeleportBeforeKick;
            Config["KickWaitSeconds"] = KickWaitSeconds;

            var maxPlayers = ConVar.Server.maxplayers;
            if (ReservedSlots > maxPlayers)
            {
                Puts("Reserved slots is larger than max players, reducing.");
                Config["ReservedSlots"] = maxPlayers;
            }
            else
                Config["ReservedSlots"] = ReservedSlots;

            SaveConfig();
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"ServerIsFull", "Server is full"},
                {"CannotConsumeStandard", "Reserved slots are full and prior player cannot use standard slots"},
                {"CannotConsumePrior", "Only reserved slots are left and standard player cannot use prior slots"},
                {"KickIsNotAllowed", "Kick for prior player is now allowed"},
                {"KickNotice", "<color=\"red\">* Caution *</color> You will be kicked in {kickseconds} seconds for prior players."},
                {"TeleportKickNotice", "<color=\"red\">* Caution *</color> You will be moved to your sleeping bag, and be kicked in {kickseconds} seconds for prior players."},
                {"KickNow", "You are kicked now."},
                {"KickedForPriorPlayer", "Kicked for prior player"},
                {"AdminOnly", "Auth level 2 required."},
                {"AdminAndModerator", "Auth level 1 or greater required."},
                {"SlotsStats", "Prior players: {priorplayers} / {reservedslots} slots, Standard players: {standardplayers} / {standardslots} slots"},
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"ServerIsFull", "サーバは満員です"},
                {"CannotConsumeStandard", "予約枠は満員で、一般枠を使用する許可がありません"},
                {"CannotConsumePrior", "一般枠は満員で、予約枠を使用する許可がありません"},
                {"KickIsNotAllowed", "優先プレイヤーのために一般プレイヤーをキックする許可がありません"},
                {"KickNotice", "<color=\"red\">* 警告 * </color> 優先プレイヤーが接続するため{kickseconds}秒後にキックさせていただきます"},
                {"TeleportKickNotice", "<color=\"red\">* 警告 * </color> 優先プレイヤーが接続するため{kickseconds}秒後にどこかの寝袋へ転送し、キックさせていただきます"},
                {"KickNow", "キックします"},
                {"KickedForPriorPlayer", "優先プレイヤーが接続したためキックしました"},
                {"AdminOnly", "管理者権限が必要です"},
                {"AdminOrModerator", "管理者かモデレータ権限が必要です"},
                {"SlotsStats", "予約枠接続数: {priorplayers} (全{reservedslots}スロット)、一般枠接続数: {standardplayers} (全{standardslots}スロット)"},
            }, this, "ja");
        }

        #endregion

        #region Initialization

        void Loaded()
        {
#if !RUST
            throw new NotSupportedException($"This plugin does not support {(covalence.Game ?? "this game")}");
#endif

            LoadDefaultConfig();
            LoadDefaultMessages();
            permission.RegisterPermission(permissionPrior, this);
        }

        #endregion

        #region Reserved Check

        object CanClientLogin(Network.Connection connection)
        {
            var slotsPlayers = GetSlotPlayers();
            bool isPrior = permission.UserHasPermission(connection.userid.ToString(), permissionPrior);

            var checkResult = LoginSlotCheck(isPrior, slotsPlayers.PriorPlayers, slotsPlayers.StandardPlayers);
            if (!checkResult.canLogin)
                return GetMessage(checkResult.messageCode, connection.userid.ToString());
            if (checkResult.needToKick != null)
            {
                foreach (var kickedPlayer in checkResult.needToKick)
                {
                    PushOut(kickedPlayer);
                }
            }
            return null;
        }

        #endregion

        #region Chat Commands

        [Command("slotstats")]
        void SlotsStatsCommand(IPlayer player, string command, string[] args)
        {
            var slotsPlayers = GetSlotPlayers();

            // for display
            var priorplayers = slotsPlayers.PriorPlayers.Count;
            var standardplayers = slotsPlayers.StandardPlayers.Count;
            var reservedslots = ReservedSlots;
            var standardslots = ConVar.Server.maxplayers - ReservedSlots;

            player.Reply(
                GetMessage("SlotsStats", player.Id.ToString())
                    .Replace("{priorplayers}", priorplayers.ToString())
                    .Replace("{reservedslots}", reservedslots.ToString())
                    .Replace("{standardplayers}", standardplayers.ToString())
                    .Replace("{standardslots}", standardslots.ToString())
            );
        }

        #endregion

        #region Console Commands

        [Command("priorityslot.pushout")]
        void PushOutCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                Puts("usage: priorityslot.pushout <name or steamID>");
                return;
            }
            if (!player.IsAdmin)
            {
                Puts(GetMessage("NeedAdminPermission", null));
                return;
            }

            var name = args[0];
            var kickedPlayer = BasePlayer.Find(name);
            if (kickedPlayer == null)
                Puts($"Player {name} not found.");
            else
            {
                Puts($"Player {name} will be kicked!");
                PushOut(kickedPlayer);
            }
        }

        #endregion

        #region Slots Methods

        private struct SlotsPlayers
        {
            internal List<BasePlayer> PriorPlayers;
            internal List<BasePlayer> StandardPlayers;
        }

        private SlotsPlayers GetSlotPlayers()
        {
            var priorPlayers = new List<BasePlayer>();
            var standardPlayers = new List<BasePlayer>();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (permission.UserHasPermission(player.UserIDString, permissionPrior))
                    priorPlayers.Add(player);
                else
                    standardPlayers.Add(player);
            }

            return new SlotsPlayers()
            {
                PriorPlayers = priorPlayers,
                StandardPlayers = standardPlayers
            };
        }

        private struct LoginSlotCheckResult
        {
            public bool canLogin;
            public string messageCode;
            public List<BasePlayer> needToKick;

            public LoginSlotCheckResult(bool pCanLogin, string pMessageCode = "", List<BasePlayer> pNeedToKick = null)
            {
                canLogin = pCanLogin;
                messageCode = pMessageCode;
                needToKick = pNeedToKick;
            }
        }

        private LoginSlotCheckResult LoginSlotCheck(bool isPriorPlayer, List<BasePlayer> priorPlayers, List<BasePlayer> standardPlayers)
        {
            var maxPlayers = ConVar.Server.maxplayers;
            if (isPriorPlayer)
            {
                if (priorPlayers.Count >= maxPlayers)
                    return new LoginSlotCheckResult(false, "ServerIsFull");
                else if (priorPlayers.Count >= ReservedSlots && !PriorCanConsumeStandard)
                    return new LoginSlotCheckResult(false, "CannotConsumeStandard");
                else if (priorPlayers.Count + standardPlayers.Count >= maxPlayers)
                {
                    if (KickForReserved)
                    {
                        var needToKick = priorPlayers.Count + standardPlayers.Count - maxPlayers;
                        var shuffledStandardPlayers = new List<BasePlayer>(standardPlayers);
                        shuffledStandardPlayers.Shuffle((uint)new System.Random().Next());
                        return new LoginSlotCheckResult(true, "", shuffledStandardPlayers.GetRange(0, needToKick));
                    }
                    else
                        return new LoginSlotCheckResult(false, "KickIsNotAllowed");
                }
                else
                    return new LoginSlotCheckResult(true);
            }
            else
            {
                if (priorPlayers.Count + standardPlayers.Count >= maxPlayers)
                    return new LoginSlotCheckResult(false, "ServerIsFull");
                else if (standardPlayers.Count < maxPlayers - ReservedSlots)
                    return new LoginSlotCheckResult(true);
                else if (StandardCanConsumePrior)
                    return new LoginSlotCheckResult(true);
                else
                    return new LoginSlotCheckResult(false, "CannotConsumePrior");
            }
        }

        private void PushOut(BasePlayer kickedPlayer)
        {
            var bags = SleepingBag.FindForPlayer(kickedPlayer.userID, true);
            bool willTeleport = bags.Length > 0 && TeleportBeforeKick;
            int kickseconds = KickWaitSeconds;

            if (willTeleport)
                kickedPlayer.ChatMessage(
                    GetMessage("TeleportKickNotice", kickedPlayer.UserIDString).Replace("{kickseconds}", KickWaitSeconds.ToString())
                );
            else
                kickedPlayer.ChatMessage(
                    GetMessage("KickNotice", kickedPlayer.UserIDString).Replace("{kickseconds}", KickWaitSeconds.ToString())
                );

            timer.Once(kickseconds, () =>
            {
                kickedPlayer.ChatMessage(GetMessage("KickNow", kickedPlayer.UserIDString));
                if (willTeleport)
                {
                    var destinationBag = bags[UnityEngine.Random.Range(0, bags.Length)];
                    kickedPlayer.Teleport(destinationBag.ServerPosition);
                }
                kickedPlayer.Kick(
                    GetMessage("KickedForPriorPlayer", kickedPlayer.UserIDString)
                );
            });
        }

        #endregion

        #region Helper Methods

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        private string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);

        #endregion
    }
}
